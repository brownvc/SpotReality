#pragma kernel CSMain

// Size of the buffers
#define WIDTH 640
#define HEIGHT 480

// Number of frames
int num_frames;
bool median_averaging;
bool mean_averaging;
bool activate_fast_median_calculation;
bool clear_buffer;
bool edge_detection;
float edgeThreshold;

// Buffers
RWStructuredBuffer<float> depth_ar;
RWStructuredBuffer<float> depth_buffer;

// buffer pos
int buffer_pos;

// Sobel filter kernels
int2 SobelX[9] = {
    int2(-1, -1), int2(0, -1), int2(1, -1),
    int2(-1,  0), int2(0,  0), int2(1,  0),
    int2(-1,  1), int2(0,  1), int2(1,  1)
};

float SobelXWeights[9] = {
    -1,  0,  1,
    -2,  0,  2,
    -1,  0,  1
};

float SobelYWeights[9] = {
    -1, -2, -1,
     0,  0,  0,
     1,  2,  1
};

[numthreads(32, 32, 1)]
void CSMain(uint3 groupId : SV_GroupID, uint3 threadId : SV_GroupThreadID)
{
    int xIndex = groupId.x * 32 + threadId.x;
    int yIndex = groupId.y * 32 + threadId.y;

    int index = xIndex + yIndex * WIDTH;
    
    if (xIndex < WIDTH && yIndex < HEIGHT)
    {
        if (edge_detection && xIndex > 0 && xIndex < WIDTH - 1 && yIndex > 0 && yIndex < HEIGHT - 1)
        {
            float gradX = depth_ar[(xIndex - 1) + (yIndex + 1) * WIDTH] * -1.0
                        //+ depth_ar[(xIndex    ) + (yIndex + 1) * WIDTH] * 0.0
                        + depth_ar[(xIndex + 1) + (yIndex + 1) * WIDTH] * 1.0
                        + depth_ar[(xIndex    ) + (yIndex    ) * WIDTH] * -2.0
                        //+ depth_ar[(xIndex - 1) + (yIndex    ) * WIDTH] * 0.0
                        + depth_ar[(xIndex + 1) + (yIndex    ) * WIDTH] * 2.0
                        + depth_ar[(xIndex - 1) + (yIndex - 1) * WIDTH] * -1.0
                        //+ depth_ar[(xIndex    ) + (yIndex - 1) * WIDTH] * 0.0
                        + depth_ar[(xIndex + 1) + (yIndex - 1) * WIDTH] * 1.0;
            
            float gradY = depth_ar[(xIndex - 1) + (yIndex + 1) * WIDTH] * -1.0
                        + depth_ar[(xIndex    ) + (yIndex + 1) * WIDTH] * -2.0
                        + depth_ar[(xIndex + 1) + (yIndex + 1) * WIDTH] * -1.0
                        //+ depth_ar[(xIndex    ) + (yIndex    ) * WIDTH] * 0.0
                        //+ depth_ar[(xIndex - 1) + (yIndex    ) * WIDTH] * 0.0
                        //+ depth_ar[(xIndex + 1) + (yIndex    ) * WIDTH] * 0.0
                        + depth_ar[(xIndex - 1) + (yIndex - 1) * WIDTH] * 1.0
                        + depth_ar[(xIndex    ) + (yIndex - 1) * WIDTH] * 2.0
                        + depth_ar[(xIndex + 1) + (yIndex - 1) * WIDTH] * 1.0;

            float temp = gradX * gradX + gradY * gradY;

            if (temp >= 0.0 && sqrt(temp) > edgeThreshold)
            {
                depth_ar[index] = 0.0;
            }
        }

        float depth_value = depth_ar[index];
        float old_value = depth_buffer[buffer_pos * WIDTH * HEIGHT + index];
        depth_buffer[buffer_pos * WIDTH * HEIGHT + index] = depth_value;

        if (clear_buffer)
        {
            for (int i = 0; i < num_frames; i++)
            {
                int idx = i * WIDTH * HEIGHT + index;
                depth_buffer[idx] = 0.0f;
            }

            depth_ar[index] = 1.0f;
        }

        if (median_averaging)
        {
            if (activate_fast_median_calculation)
            { // TODO : check the case of old_value being the median
                float median_value = depth_buffer[(num_frames - 1) * WIDTH * HEIGHT + index];

                if ((old_value - median_value) * (depth_value - median_value) > 0) // The new value and the old are on the same side
                {
                    depth_ar[index] = median_value;
                }
                else
                {
                    float new_med = -1;
                    int dir = -1;
                    int count = 0;
                    if (old_value < median_value) dir = 1; 
                    else if (old_value == median_value && depth_value > median_value) dir = 1;

                    for (int i = 0; i < 19; i++)
                    {
                        float depth_i = depth_buffer[i * WIDTH * HEIGHT + index];
                        if (depth_i * dir > median_value * dir)
                        {
                            count ++;
                            if (depth_i * dir < new_med * dir || new_med == -1)
                            { 
                                new_med = depth_buffer[i * WIDTH * HEIGHT + index];  
                            }
                        }
                    }
                    if (count >= 10) 
                    {
                        depth_buffer[(num_frames - 1) * WIDTH * HEIGHT + index] = new_med;    
                    }
                    depth_ar[index] = depth_buffer[(num_frames - 1) * WIDTH * HEIGHT + index];
                }
            }
            else
            {
                float tmp[19];
                for (int q = 0; q < num_frames - 1; q++)
                {
                    int idx = q * WIDTH * HEIGHT + index;
                    tmp[q] = depth_buffer[idx];
                }

                int i, j;
                float key;
                int n = num_frames - 1;
                for (i = 1; i < n; i++) 
                {
                    key = tmp[i];
                    j = i - 1;

                    while (j >= 0 && tmp[j] > key) {
                        tmp[j + 1] = tmp[j];
                        j = j - 1;
                    }
                    tmp[j + 1] = key;
                }
                depth_ar[index] = tmp[9];
                depth_buffer[(num_frames - 1) * WIDTH * HEIGHT + index] = tmp[9];
            } 
        }
        else if (mean_averaging)
        {
            float weighted_sum = 0.0;
            float total_weight = 0.0001;
        
            for (int i = 0; i < num_frames - 1; i++)
            {
                int idx = i * WIDTH * HEIGHT + index;
                //float weight = 1.0;
                //weight = 1.0;
                if (depth_buffer[idx] > 0)
                {
                    weighted_sum += depth_buffer[idx];
                    total_weight += 1.0;
                }
            }
            
            depth_ar[index] = weighted_sum / total_weight;
        }
    }
}
