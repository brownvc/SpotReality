#pragma kernel EdgeDetection
#pragma kernel MeanAveraging
#pragma kernel ClearBuffer
#pragma kernel MedianAveragingFast
#pragma kernel MedianAveragingNaive

// Size of the buffers
#define WIDTH 640
#define HEIGHT 480

// Number of frames
int num_frames;
bool activate_fast_median_calculation;
bool clear_buffer;
float edgeThreshold;

// Buffers
RWStructuredBuffer<float> depth_ar;
RWStructuredBuffer<float> depth_buffer;

// buffer pos
int buffer_pos;

[numthreads(16, 16, 1)]
void EdgeDetection(uint3 groupId : SV_GroupID, uint3 threadId : SV_GroupThreadID)
{
    int xIndex = groupId.x * 16 + threadId.x;
    int yIndex = groupId.y * 16 + threadId.y;

    int index = xIndex + yIndex * WIDTH;

    if (xIndex > 0 && xIndex < WIDTH - 1 && yIndex > 0 && yIndex < HEIGHT - 1)
    {
        float gradX = depth_ar[(xIndex - 1) + (yIndex + 1) * WIDTH] * -1.0
                    //+ depth_ar[(xIndex    ) + (yIndex + 1) * WIDTH] * 0.0
                    + depth_ar[(xIndex + 1) + (yIndex + 1) * WIDTH] * 1.0
                    + depth_ar[(xIndex    ) + (yIndex    ) * WIDTH] * -2.0
                    //+ depth_ar[(xIndex - 1) + (yIndex    ) * WIDTH] * 0.0
                    + depth_ar[(xIndex + 1) + (yIndex    ) * WIDTH] * 2.0
                    + depth_ar[(xIndex - 1) + (yIndex - 1) * WIDTH] * -1.0
                    //+ depth_ar[(xIndex    ) + (yIndex - 1) * WIDTH] * 0.0
                    + depth_ar[(xIndex + 1) + (yIndex - 1) * WIDTH] * 1.0;
            
        float gradY = depth_ar[(xIndex - 1) + (yIndex + 1) * WIDTH] * -1.0
                    + depth_ar[(xIndex    ) + (yIndex + 1) * WIDTH] * -2.0
                    + depth_ar[(xIndex + 1) + (yIndex + 1) * WIDTH] * -1.0
                    //+ depth_ar[(xIndex    ) + (yIndex    ) * WIDTH] * 0.0
                    //+ depth_ar[(xIndex - 1) + (yIndex    ) * WIDTH] * 0.0
                    //+ depth_ar[(xIndex + 1) + (yIndex    ) * WIDTH] * 0.0
                    + depth_ar[(xIndex - 1) + (yIndex - 1) * WIDTH] * 1.0
                    + depth_ar[(xIndex    ) + (yIndex - 1) * WIDTH] * 2.0
                    + depth_ar[(xIndex + 1) + (yIndex - 1) * WIDTH] * 1.0;

        float temp = gradX * gradX + gradY * gradY;

        if (temp >= 0.0 && sqrt(temp) > edgeThreshold)
        {
            depth_ar[index] = 0.0;
        }
    }
}

[numthreads(16, 16, 1)]
void MeanAveraging(uint3 groupId : SV_GroupID, uint3 threadId : SV_GroupThreadID)
{
    int xIndex = groupId.x * 16 + threadId.x;
    int yIndex = groupId.y * 16 + threadId.y;

    int index = xIndex + yIndex * WIDTH;

    if (xIndex < WIDTH && yIndex < HEIGHT)
    {
        float weighted_sum = 0.0;
        float total_weight = 0.0001;

        depth_buffer[buffer_pos * WIDTH * HEIGHT + index] = depth_ar[index];
        
        for (int i = 0; i < num_frames - 1; i++)
        {
            int idx = i * WIDTH * HEIGHT + index;
            //float weight = 1.0;
            //weight = 1.0;
            if (depth_buffer[idx] > 0)
            {
                weighted_sum += depth_buffer[idx];
                total_weight += 1.0;
            }
        }
            
        depth_ar[index] = weighted_sum / total_weight;
    }
}

[numthreads(16, 16, 1)]
void ClearBuffer(uint3 groupId : SV_GroupID, uint3 threadId : SV_GroupThreadID)
{
    int xIndex = groupId.x * 16 + threadId.x;
    int yIndex = groupId.y * 16 + threadId.y;

    if (xIndex < WIDTH && yIndex < HEIGHT)
    {
        for (int i = 0; i < num_frames; i++)
        {
            int idx = i * WIDTH * HEIGHT + xIndex + yIndex * WIDTH;
            depth_buffer[idx] = 0.0f;
        }
    }
}

[numthreads(16, 16, 1)]
void MedianAveragingFast(uint3 groupId : SV_GroupID, uint3 threadId : SV_GroupThreadID)
{
    int xIndex = groupId.x * 16 + threadId.x;
    int yIndex = groupId.y * 16 + threadId.y;

    int index = xIndex + yIndex * WIDTH;
    
    if (xIndex < WIDTH && yIndex < HEIGHT)
    {
        float depth_value = depth_ar[index];
        float old_value = depth_buffer[buffer_pos * WIDTH * HEIGHT + index];
        depth_buffer[buffer_pos * WIDTH * HEIGHT + index] = depth_value;

        float median_value = depth_buffer[(num_frames - 1) * WIDTH * HEIGHT + index];

        if ((old_value - median_value) * (depth_value - median_value) > 0) // The new value and the old are on the same side
        {
            depth_ar[index] = median_value;
        }
        else
        {
            float new_med = -1;
            int dir = -1;
            int count = 0;
            if (old_value < median_value) dir = 1; 
            else if (old_value == median_value && depth_value > median_value) dir = 1;

            for (int i = 0; i < 19; i++)
            {
                float depth_i = depth_buffer[i * WIDTH * HEIGHT + index];
                if (depth_i * dir > median_value * dir)
                {
                    count ++;
                    if (depth_i * dir < new_med * dir || new_med == -1)
                    { 
                        new_med = depth_buffer[i * WIDTH * HEIGHT + index];  
                    }
                }
            }
            if (count >= 10) 
            {
                depth_buffer[(num_frames - 1) * WIDTH * HEIGHT + index] = new_med;    
            }
            depth_ar[index] = depth_buffer[(num_frames - 1) * WIDTH * HEIGHT + index];
        }
    }
}

[numthreads(16, 16, 1)]
void MedianAveragingNaive(uint3 groupId : SV_GroupID, uint3 threadId : SV_GroupThreadID)
{
    int xIndex = groupId.x * 16 + threadId.x;
    int yIndex = groupId.y * 16 + threadId.y;

    int index = xIndex + yIndex * WIDTH;
    
    if (xIndex < WIDTH && yIndex < HEIGHT)
    {
        depth_buffer[buffer_pos * WIDTH * HEIGHT + index] = depth_ar[index];

        float tmp[19];
        for (int q = 0; q < num_frames - 1; q++)
        {
            int idx = q * WIDTH * HEIGHT + index;
            tmp[q] = depth_buffer[idx];
        }

        int i, j;
        float key;
        int n = num_frames - 1;
        for (i = 1; i < n; i++) 
        {
            key = tmp[i];
            j = i - 1;

            while (j >= 0 && tmp[j] > key) {
                tmp[j + 1] = tmp[j];
                j = j - 1;
            }
            tmp[j + 1] = key;
        }
        depth_ar[index] = tmp[9];
        depth_buffer[(num_frames - 1) * WIDTH * HEIGHT + index] = tmp[9];
    }
}
