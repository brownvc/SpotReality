#pragma kernel CSMain

// Size of the buffers
#define WIDTH 640
#define HEIGHT 480

// Number of frames
int num_frames;
bool median_averaging;
bool activate_fast_median_calculation;

// Buffers
RWStructuredBuffer<float> depth_ar;
RWStructuredBuffer<float> confidence_ar;
RWStructuredBuffer<float> depth_buffer;
RWStructuredBuffer<float> confidence_buffer;

// buffer pos
int buffer_pos;

[numthreads(WIDTH, 1, 1)]
void CSMain(uint3 groupId : SV_GroupID, uint3 threadId : SV_GroupThreadID)
{
    int index = threadId.x + groupId.y * WIDTH;
    float depth_value = depth_ar[index];
    
    if (threadId.x < WIDTH && groupId.y < HEIGHT)
    {
        depth_buffer[buffer_pos * WIDTH * HEIGHT + index] = depth_value;

        if (median_averaging)
        {
            if (activate_fast_median_calculation)
            {
                for (int i = buffer_pos; i > 0 && depth_buffer[i * WIDTH * HEIGHT + index] < depth_buffer[(i - 1) * WIDTH * HEIGHT + index]; --i) 
                {
                    int index1 = i * WIDTH * HEIGHT + index;
                    int index0 = (i - 1) * WIDTH * HEIGHT + index;
                    int temp = depth_buffer[index1];
                    depth_buffer[index1] = depth_buffer[index0];
                    depth_buffer[index0] = temp;
                }

                for (int i = buffer_pos; i < num_frames - 1 && depth_buffer[i * WIDTH * HEIGHT + index] > depth_buffer[(i + 1) * WIDTH * HEIGHT + index]; ++i) 
                {
                    int index1 = i * WIDTH * HEIGHT + index;
                    int index0 = (i + 1) * WIDTH * HEIGHT + index;
                    int temp = depth_buffer[index1];
                    depth_buffer[index1] = depth_buffer[index0];
                    depth_buffer[index0] = temp;
                }
            }
            else
            {
                float tmp[20];
                for (int q = 0; q < num_frames; q++)
                {
                    int idx = q * WIDTH * HEIGHT + index;
                    tmp[q] = depth_buffer[idx];
                }

                int i, j;
                float key;
                int n = 20;
                for (i = 1; i < n; i++) 
                {
                    key = tmp[i];
                    j = i - 1;

                    while (j >= 0 && tmp[j] > key) {
                        tmp[j + 1] = tmp[j];
                        j = j - 1;
                    }
                    tmp[j + 1] = key;
                }
                depth_ar[index] = tmp[10];
            } 
        }
        else
        {
            confidence_buffer[buffer_pos * WIDTH * HEIGHT + index] = confidence_ar[index];

            float weighted_sum = 0.0;
            float total_weight = 0.0;
        
            for (int i = 0; i < num_frames; i++)
            {
                int idx = i * WIDTH * HEIGHT + index;
                float weight = confidence_buffer[idx];
                //weight = 1.0;
                weighted_sum += depth_buffer[idx] * weight;
                total_weight += weight;
            }

            if (total_weight > 0.0)
            {
                depth_ar[index] = weighted_sum / total_weight;
                confidence_ar[index] = total_weight / num_frames;
            }
            else
            {
                depth_ar[index] = 0.0;
                confidence_ar[index] = 0.0;
            }
        }
    }
}
