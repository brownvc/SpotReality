#pragma kernel CSMain

// Size of the buffers
#define WIDTH 640
#define HEIGHT 480

// Number of frames
int num_frames;
bool median_averaging;
bool activate_fast_median_calculation;

// Buffers
RWStructuredBuffer<float> depth_ar;
RWStructuredBuffer<float> confidence_ar;
RWStructuredBuffer<float> depth_buffer;
RWStructuredBuffer<float> confidence_buffer;

// buffer pos
int buffer_pos;

[numthreads(WIDTH, 1, 1)]
void CSMain(uint3 groupId : SV_GroupID, uint3 threadId : SV_GroupThreadID)
{
    int index = threadId.x + groupId.y * WIDTH;
    float depth_value = depth_ar[index];
    
    if (threadId.x < WIDTH && groupId.y < HEIGHT)
    {   
        float old_value = depth_buffer[buffer_pos * WIDTH * HEIGHT + index];
        depth_buffer[buffer_pos * WIDTH * HEIGHT + index] = depth_value;

        if (median_averaging)
        {
            //if (activate_fast_median_calculation)
            //{ // TODO : check the case of old_value being the median
            //    float median_value = depth_buffer[(num_frames - 1) * WIDTH * HEIGHT + index];


            //    if ((old_value - median_value) * (depth_value - median_value) > 0) // The new value and the old are on the same side
            //    {
            //        depth_ar[index] = median_value;
            //    }
            //    else
            //    {
            //        float new_med = -1;
            //        int dir = -1;
            //        int count = 0;
            //        if (old_value < median_value) dir = 1; 
            //        else if (old_value == median_value && depth_value > median_value) dir = 1;

            //        for (int i = 0; i < 19; i++)
            //        {
            //            float depth_i = depth_buffer[i * WIDTH * HEIGHT + index];
            //            if (depth_i * dir > median_value * dir)
            //            {
            //                count ++;
            //                if (depth_i * dir < new_med * dir || new_med == -1)
            //                { 
            //                    new_med = depth_buffer[i * WIDTH * HEIGHT + index];  
            //                }
            //            }
            //        }
            //        if (count >= 10) 
            //        {
            //            depth_buffer[(num_frames - 1) * WIDTH * HEIGHT + index] = new_med;    
            //        }
            //        depth_ar[index] = depth_buffer[(num_frames - 1) * WIDTH * HEIGHT + index];
            //    }
            //    //depth_ar[index] = depth_buffer[9 * WIDTH * HEIGHT + index];
            //    //depth_ar[index] = median_value;
            //}
            //else
            //{
                float tmp[19];
                for (int q = 0; q < num_frames - 1; q++)
                {
                    int idx = q * WIDTH * HEIGHT + index;
                    tmp[q] = depth_buffer[idx];
                }

                int i, j;
                float key;
                int n = num_frames - 1;
                for (i = 1; i < n; i++) 
                {
                    key = tmp[i];
                    j = i - 1;

                    while (j >= 0 && tmp[j] > key) {
                        tmp[j + 1] = tmp[j];
                        j = j - 1;
                    }
                    tmp[j + 1] = key;
                }
                depth_ar[index] = tmp[9];
                depth_buffer[(num_frames - 1) * WIDTH * HEIGHT + index] = tmp[9];
            //} 
        }
        else
        {
            confidence_buffer[buffer_pos * WIDTH * HEIGHT + index] = confidence_ar[index];

            float weighted_sum = 0.0;
            float total_weight = 0.0;
        
            for (int i = 0; i < num_frames; i++)
            {
                int idx = i * WIDTH * HEIGHT + index;
                float weight = confidence_buffer[idx];
                //weight = 1.0;
                weighted_sum += depth_buffer[idx] * weight;
                total_weight += weight;
            }

            if (total_weight > 0.0)
            {
                depth_ar[index] = weighted_sum / total_weight;
                confidence_ar[index] = total_weight / num_frames;
            }
            else
            {
                depth_ar[index] = 0.0;
                confidence_ar[index] = 0.0;
            }
        }
    }
}
