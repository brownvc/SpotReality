#pragma kernel CSMain
#define H 480
#define W 640

RWBuffer<float> depth;

#define SIGMA 10.0
#define BSIGMA 0.1
#define MSIZE 5

float normpdf(float x, float sigma)
{
	return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;
}

float normpdf3(float v,float sigma)
{
	return 0.39894*exp(-0.5*v*v/(sigma*sigma))/sigma;
}


[numthreads(W, 1, 1)]
void CSMain(uint3 groupId : SV_GroupID, uint3 threadId : SV_GroupThreadID)
{
	uint index = threadId.x + groupId.y * W;
	float c = depth[index];
		
	//declare stuff
	const int kSize = (MSIZE-1)/2;
	float kernel[MSIZE];
	float final_colour = 0.0f;
		
	//create the 1-D kernel
	float Z = 0.0;
	for (int j = 0; j <= kSize; ++j)
	{
		kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), SIGMA);
	}
	
	float cc;
	float factor;
	float bZ = 1.0/normpdf(0.0, BSIGMA);
	//read out the texels
	for (int i=-kSize; i <= kSize; ++i)
	{
		for (int j=-kSize; j <= kSize; ++j)
		{
			cc = depth[threadId.x + i + (groupId.y + j) * W];
			factor = normpdf3(cc-c, BSIGMA)*bZ*kernel[kSize+j]*kernel[kSize+i];
			Z += factor;
			final_colour += factor*cc;
		}
	}
		
		
	depth[index] = final_colour/Z;
}

//float sigmaColor = 0.15;
//float sigmaSpace = 3.0;

//float Gaussian(float x, float sigma) {
//    return exp(-((x * x) / (2.0 * sigma * sigma)));
//}

//[numthreads(W, 1, 1)]
//void CSMain(uint3 groupId : SV_GroupID, uint3 threadId : SV_GroupThreadID)
//{
//	uint index = threadId.x + groupId.y * W;
//    float centralColor = depth[index];
//    float finalColor = 0.0f;
//    float totalWeight = 0.0f;

//    // Define the size of the kernel
//    int kernelRadius = 2; // For a 5x5 kernel

//	if (depth[index] > 0.1f && threadId.x >= 2 && threadId.x < W - 2 && groupId.y >= 2 && groupId.y < H - 2)
//    {
//		for (int dy = -kernelRadius; dy <= kernelRadius; ++dy) 
//		{
//			for (int dx = -kernelRadius; dx <= kernelRadius; ++dx) 
//			{
//				uint pos = threadId.x + dx + (groupId.y + dy) * W;

//				float neighborColor = depth[pos];

//				float weight = Gaussian(neighborColor - centralColor, sigmaColor) * Gaussian(length(float2(dx, dy)), sigmaSpace);

//				finalColor += neighborColor * weight;
//				totalWeight += weight;
//			}
//		}

//		finalColor /= totalWeight;
//		depth[index] = finalColor;
//    }
//}